//HookExam.js

// Hooks
// 16버전에 출시된 기능.
// 함수형 컴포넌트가 상태관리가 너무 어려움.
// 함수형 컴포넌트에서도 상태관리를 할수있도록 다양한 메서드들을 추가.
//  그중 하나가 useState
// useState : 상태관리 Hook(기본 Hook)
//  -> 함수 파라미터 기본값 설정
//  -> 그 외 컴포넌트의 전반적인 상태를 관리하는 Hook
// 사용방식 const [현재상태값, 해당값을 업데이트하는 함수명] = useState(초기상태값)

// useEffect : 컴포넌트 랜더링시 특정 작업을 수행하도록 설정하는 Hook
// 마운트, 업데이트, 언마운트시 우리가 원하는대로 수행하기위해
// 사용하는 Hook, state와 다르게 필수까진 아님.

// useContext : useState가 컴포넌트 단위의 지역변수 느낌
//  -> 전역변수 느낌.
// 상태 자체를 전역으로 관리하는 방법.(컴포넌트간 값 공유)
// useRef : 참조 훅
//  -> .current 프로퍼티로 전달된 인자로 초기화된 변경가능한
//     ref 객체를 반환하며 반환된 객체는 컴포넌트의 라이프사이클을 통해 관리.
//  랜더링에 필요하지 않을 값을 참조할수 있는 훅
//   -> 컴포넌트가 특정정보를 기억하도록 하고싶지만 
//      만약 새 랜더링을 막고싶다면 ref를 사용함.
//  react 포스트잇. = 기억하고 싶은 내용을 저장할때 쓰는 state와는 다른 변수 선언.
//  useEffect와 연계해서 사용하기도 좋음.
//  가상DOM을 활용하는것이 아닌 DOM 직접 조작.(핵심적인 내용)



// useReducer
// useMemo
// useCallback
// useLayoutEffect
// Hook 커스텀.


// Hook은 일반함수와 거의 비슷하긴함.
// 일반함수 그냥 쓰는게 나을거같은데 굳이써야함?
// Hook의 장점
// 1. 코드가 간결해짐.
//  -> 함수형 컴포넌트가 클래스형 컴포넌트를 좀더 단순히 쓰기위해 나온개념
//     문제는 기능을 다 만들수가 없어서 Hook이 등장.
// 2. 재사용성
//  -> 훅은 커스텀이 가능.
// 3. 컴포넌트 분리
// 4. 라이프 사이클 메서드 문제 해결.

// 라이프사이클(컴포넌트의 생명주기)
// CBD 개발방식에서는 라이프사이클이 존재.
// 컴포넌트가 생성되고 업데이트, 소멸될떄까지의 상태를 설명(설정)하는 메서드

// 마운트, 업데이트, 언마운트

// Hooks의 등장으로 클래스형 컴포넌트를 굳이 강요받지 않음.
// Hooks은 함수형 컴포넌트 내에서만 사용가능하냐?
//  -> Hooks의 규칙 : 최상위 레벨에서만 호출할것.
//     (리엑트의 함수형 컴포넌트의 구조 자체가 Hooks의 호출순서에 의존하여
//      해당 Hooks이 관리하는 상태와의 연관성 유지때문에)

